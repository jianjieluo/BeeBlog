

# Chapter 7 死锁

@(Operating System)


[toc]

## 7.2 死锁特征

### 7.2.1 必要条件

互斥
:	至少有一个资源必须处于非共享模式，即一次只有一个进程在使用。

占有并等待
:	一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有

非抢占
:	资源不能被抢占，即资源只能在进程完成任务之后自动释放

循环等待
:	相互请求，形成了一个环

### 7.2.2资源分配图

节点集合V可分成两种类型的节点：**系统活动进程的集合P**和**系统所有资源类型的集合R**。

申请边（request edge）
:	由进程Pi到资源类型Rj的有向边$P_i \to R_j$，它表示进程Pi已经申请了资源类型Rj的一个实例，并且**在等待改资源**

分配边（assignment edge）
:	由资源类型Rj到进程Pi的有向边$R_j \to P_i$，它表示资源类型Rj的一个实例已经分配给了进程Pi。

在图上，用圆形表示进程，用矩形表示资源类型。当有申请时，就加入一条申请边；当申请满足时，就立即转成分配边；当不在需要该资源时，删除分配边。

如果资源分配图没有环，那么系统就不处于死锁状态。另一方面，如果有环，那么系统可能会处于死锁状态。

### 死锁处理方法

1. 使用协议来预防或避免死锁
2. 忽略死锁，再通过周期检测。检测到死锁，对此加以恢复。
3. 忽略死锁问题，认为死锁不会发生。（让程序开发者，写程序时，自己处理，保证不会有死锁产生）

####死锁预防

死锁预防是一组方法，以确保至少一个必要条件不成立。（缺点：导致低设备利用率和系统吞吐率)

1. **破坏“互斥”** : 保证所有资源都是共享资源。比如 多次读取文件
2. **破坏“占有并等待”**：必须保证：当一个进程申请一个资源时，它不能占有其他资源。一种可用的协议是：要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。允许进程在没有资源时，才可申请资源。（缺点：资源利用率较低和可能发生饥饿）
3. **破坏“非抢占”**：如果一个进程占有资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占。也可以说：一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须隐式释放已占有的全部资源，若需要再重新申请。
4. **破坏“循环等待”条件**: 采用资源有序分配法： 把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。

####死锁避免 

死锁避免(deadlock avoidance)
:	要求操作系统事先得到有关进程申请资源和使用资源的额外信息。有了这些信息，系统可以确定：对于一个申请，进程是否应该等待。

#####安全状态
（概念补充）：
-  存在一个安全的序列，使进程能按该序列不死锁的运行，则说明系统处于安全状态。
- 安全状态不是死锁状态。相反，死锁状态是不安全状态。然而，不是所有不安全状态都能导致死锁状态。不安全状态，主要表明的是 操作系统不能阻止进程以会导致死锁的方式申请资源。关系图，如图所示： 
![deadlock](http://or5jajfqs.bkt.clouddn.com/osnote/chapter7/deadlock.png)

##### 1. 资源分配图算法

需求边（claim edge）
:	表示进程可能在某个时候申请资源，在图中用虚线表示。

当进程申请资源时，需求边变成了申请边。当资源被分配给进程时，申请边变成了分配边。当进程释放资源时，分配边变成了需求边。
此算法针对的是每种资源只有一个实例的情况。其主要就是保证在资源分配图中不存在环即可。具体的实现是：假设进程Pi申请资源Rj，只有在申请边$P_i \to R_j$变成分配边$R_j \to P_i$而不会导致资源分配图成环时，才允许申请。

##### <font color="red">2. 银行家算法</font>

针对的是每种资源类型有多个实例的资源分配系统。

设n为系统进程的个数，m为资源类型的种类，定义如下数据结构：
- Available：长度为m的向量，表示每种资源的现有实例的数量。
- Max：n*m的矩阵，定义每个进程的最大需求。
- Allocation：n*m的矩阵，定义每个进程现在所分配的各种资源类型的实例数量。
- Need：n*m的矩阵，表示每个进程还需要的剩余的资源。

在这两个的基础上有**安全性算法**和**资源请求算法**，具体课本P222.

####死锁检测
**通过一个算法周期检测当前状态下是否存在死锁**。若有，则纠正死锁状态。

1. 每种资源只有单个实例情况 ： 从资源分配图中，删除所有资源类型节点，合并适当边，就可以得到等待图。
如图所示： 接下来只需要维护等待图，保证其不出现环即可。（若出现，则通过一定策略，消去）为了检测死锁，系统需要维护等待图，并周期性地调用在图中搜索的算法。从图中检测环的算法需要$n^2$级别的操作。
![resource_img](http://or5jajfqs.bkt.clouddn.com/osnote/chapter7/resource_img.png)

2. 每种资源类型可有多个实例：类似于银行家算法，P225


####死锁恢复 

让系统从死锁状态中自动回复过来。

#####1.进程终止

- 终止所有死锁进程
- 一次终止一个进程直到取消死锁循环为止。 （开销相当大，每终止一个都需要调用一次死锁检测算法）（最好选择一个“代价最小”的进程先终止）

#####2.资源抢占
通过资源抢占来取消死锁，逐步从进程中抢占资源给其他进程使用，直到死锁环被打破为止。 问题：

1. 如何选择牺牲品（代价最小）
2. 如何回滚：即执行完毕后，必须将进程回滚到某个安全状态，以便从该状态重启进程。最简单的方法是**完全回滚**：终止进程并重新执行。
3. 如何确保不会发生饥饿（代价最小的那个老是被杀）

## 额外学习知识

### 同步与互斥的区别
`互斥`：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　

`同步`：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

##Q&A
1. 互斥和非抢占所强调的有什么不同？
　　互斥强调的是，不能被**共享**，一次只能一个进程享用，但是这个时候如果允许抢占的话是可以被抢占的，抢来抢去。如果不是互斥，那么就是被共享了

2. 破坏循环条件的哲学家就餐问题的实际例子
　　考虑最极端的情况，也会到最后，1号筷子的两边的哲学家不能同时拿筷子，这个时候没有拿到1号筷子的那位哲学家因为优先级问题也不能够去拿另一支筷子，所以这个时候破坏了循环等待，可以避免死锁。