@(Operating System)

# Chpater 9  虚拟内存

## 9.1 背景
第8章讨论的策略都是同时将多个进程存放在内存中，以便多道程序设计。不过，这些策略都需要**在进程执行之前将整个进程放在内存中。**

能够执行只有部分在内存中的程序带来的好处：
1. 不受现有的物理内存空间限制，简化了编程工作量
2. 更多的程序可以同时执行
3. 用户程序的交换到内存的I/O减少，用户程序运行得更快。

虚拟内存（virtual memory）技术允许执行进程不必完全在内存中。显著优点是程序可以比物理内存要大。进而将用户逻辑内存与物理内存分开。除了这一点，虚拟内存也允许文件和内存通过共享页而为两个或多个进程所共享。通常，库是按只读的方式来链接每个进程的空间。共享该内存区域的进程认为它是其虚拟地址空间的一部分，而事实上这部分是共享的。

进程的**虚拟地址空间**（就是逻辑地址空间）就是进程如何在内存中存放的逻辑（或虚拟）视图。通常，该视图为进程从某一逻辑地址（如地址0）开始，连续存放，如下图所示。根据第八章，物理地址可以按页帧来组织，且分配给进程的物理页帧页可能不是连续的。这就需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。

![virtual_memory_room|center](http://or5jajfqs.bkt.clouddn.com/osnote/chapter9/virtual_memory_room.png)

虚拟内存的实现方式分为按需调页（demand paging）和按需调段（demand segmentation）。

## 9.2 按需调页

按需调页（demand paging）方法只在需要时才会调入相应的页，这种技术常为虚拟内存系统所采用。
懒惰交换（lazy swapper）只有在需要页时，才将它调入内存。
交换程序（swapper）对整个进程进行操作，而调页程序（pager）只是对进程的单个页进行操作。因此，在讨论有关按需调页的时，需要使用调页程序而不是交换程序。

### 9.2.1 基本概念
如果进程从不试图访问标记为无效的页，那并没有什么影响。因此，如果推测正确并且只调入所有真正需要的页，那么进程就可以如同所有页都已经调入一样正常运行。当进程执行和访问那些驻留在内存中的页（resident page）时，执行会正常进行。

对标记为无效页表记录的访问会产生**页错误陷阱**（page-fault trap），这种陷阱是由于操作系统未能将所需的页调入内存引起的。（P275有处理过程）
1. 检查进程的内部页表（通常与PCB一起保存），以确定该引用是合法还是非法的地址访问。
2. 如果引用非法，那么终止进程。如果引用有效但是尚未调入页面，那么现在应该调入
3. 查找一个空闲帧
	4. 如果有空闲帧，那么就使用它
	5. 如果没有空闲帧，那么就**使用页置换算法**选择一个**牺牲帧**(victim frame)。
	6. 将牺牲帧的内容写到磁盘上，改变页表和帧表。
4. 将所需页读入（新）空闲帧，修改进程的内部表和页表，以表示该页已经在内存中。
5. 重新开始因陷阱而中断的指令。进程现在能访问所需的页，就好像它似乎总在内存中。

![Steps_in_handling_a_page_fault|center](http://or5jajfqs.bkt.clouddn.com/osnote/chapter9/Steps_in_handling_a_page_fault.png)

纯粹按需调页(pure demand paging)
:	只有需要时才将页调入

支持按需调页的硬件与分页和交换的硬件一样：
- 页表：该表能通过有效-无效位或保护位的特定值，将条目设为无效。
- 次级存储器：用来交换的这部分磁盘称为交换空间（swap space）

### 9.2.2 按需调页的性能
设p为页错误的概率（$0 \leq p \leq 1$）。希望p接近于0，即页错误很少。那么**有效访问时间**为：
EAT = (1 - p) * memory access time + p * 页错误时间

不管如何，都有如下三个主要的页错误处理时间：
1. 处理页错误中断
2. 读入页
3. 重新启动进程

对于按需调页，需要重点降低页错误率，还有是对于交换空间的处理和使用。

## 9.3 写时复制

通过采用类似页面共享的技术，进程fork的时候的开始阶段可能不需要按需调页，减少无用的复制开销。

## 9.4 页面置换

### 9.4.1 基本页置换

页置换（page-replacement）
:	如果没有空闲帧，那么就查找当前没有使用的帧，并将其释放。如何释放：将其内容写到交换空间，并改变页表（和所有其他的表），以表示该页不在内存中。

通过修改页错误处理程序以包括页置换可有效避免内存的过度分配（over-allocation）。
可以通过使用修改位（modify bit）或脏位（dirty bit）以降低额外开销，只有被修改过的页需要被写到磁盘上，否则只需要直接覆盖即可。

页置换是按需调页的基础。它分开了逻辑内存和物理内存。采用这种机制，小的物理内存能为程序员提供巨大的虚拟内存。降低额外开销，只有被修改过的页需要被写到磁盘上。

为实现按需调页，必须解决两个主要问题：必须开发**帧分配算法**（frame-allocation algorithm）和**页置换算法**（page-replacement algorithm）。

### 9.4.2 FIFO页置换
选择最旧的页被替换。

Belady异常（Belady’s anomaly）
:	对于部分页置换算法，页错误率可能会随着所分配的帧数的增加而增加，尽管原期望为进程内存会改善其性能。

### 9.4.3 最优置换

最优页置换算法（optimal page-replacement algorithm）会置换未来最长时间不会使用的页。
这种算法不是实际可行的算法，可用来作为衡量各种具体算法的标准，具有理论意义。

### 9.4.4 LRU页置换
最近最少使用算法（least-recently-used algorithm, LRU）会置换过去最长时间没有使用的页。
思路和最优置换类似，只是看的方向相反。
最优置换和LRU置换都没有Belady异常，这两个都属于同一类算法，称为栈算法。

### 9.4.5 近似LRU页置换

许多系统通过**引用位**(reference bit)方式提供一定的支持。页表内的每一项都关联着一个引用位，每当引用了一个页时，相应页表的引用位就被硬件置位。开始，操作系统会将所有引用位都清0。随着用户进程的执行，与引用页相关的引用位卑硬件置位为1。之后，通过检查引用位，能够确定哪些页使用过而哪些页未使用过。虽然不知到引用的顺序，但是知道哪些页用过哪些页没有过。这信息时许多近似LRU页置换算法的基础。

#### 1. 附加引用位算法

为位于内存内的每个表中的页保留一个8位的字节。每过一定时间周期，作系统把每个页的引用位转移到其8位字节的高位，而其他位右移一位，抛弃最低位。那么可以知道该页在最近8个时间周期内的使用情况。如果将这8位字节作为无符号整数，**那么具有最小值的页位LRU页，且可以被置换。**

#### 2. 二次机会算法

基础算法是FIFO，当要选择一个页时，看队头的引用位若为1，则给二次机会，引用位清0，且到达时间设为当前时间。

一种实现二次机会算法的方法是采用循环队列，指针一直在扫到0的页，其中经过的1的页就把引用位置为0。

#### 3. 增强型二次机会算法

通过引用位和修改位作为一对有序对来考虑，可以改进二次机会算法。采用这2个位，有下面4中类型的可能：
1. （0，0）——用于置换的最佳页
2. （0，1）最近没有使用但修改过——不是很好，因为在置换前需要将页写到磁盘
3. （1，0）最近使用过但是没有修改——它有可能很快又要被使用。
4. （1，1）

当页需要被置换时，用时钟算法扫描队列，检查所指页属于哪个类型。这种方法与简单时钟算法的区别在与这里给那些已经修改过的页以更改的级别，从而降低了所需I/O的数量。

### 9.4.6 继续计数的页置换

为每个页保留一个用于记录其引用次数的计数器。
- 最不经常使用页置换算法
- 最常使用页置换算法

### 9.4.7 页缓冲算法

将换出去的页写到缓冲里面。

### 9.4.8 应用程序与页置换

## 9.5 帧分配

### 9.5.3 全局分配与局部分配

全局分配
:	允许一个进程从所有帧集合中选择一个置换帧，而不管该帧是否已分配给其他进程。问题是进程不能控制其页错误率

局部置换
:	进程内存中的页只受该进程本身的调页行为所影响。问题是：局部置换不能使用其他进程的不常用的内存，所以会阻碍一个进程。

全局分配通常会有更好的系统吞吐量。

## 9.6 系统颠簸

发生在没有“足够”帧的进程。如果进程没有它所需要的活跃使用的帧，那么它会很快产生页错误。这时，必须置换某个页。然而，其所有页都在使用，它置换一个页，但又立刻再次需要这个页。因此，它会一而再地产生页错误，置换一个页，而该页又立即出错且需要立即调进来。
这种频繁的页调度行为称为**颠簸**（thrashing）。**如果一个进程在换页上用的时间要多于执行时间，那么这个进程就在颠簸。**

### 9.6.2 工作集合模型

### 9.6.3 页错误频率