@(Operating System)

[toc]

# Chapter 8 内存管理

## 8.1 背景

### 8.1.1 基本硬件
CPU所能直接访问的存储器只有**内存**和**处理器内的寄存器**。因此，执行指令以及指令使用的数据必须在这些直接可访问的存储设备上。如果数据不在内存中，那么在CPU使用前必须先把数据移到内存中。

CPU计算通常在一个时钟周期内即可完成，但是内存访问用的时间要多得多，这个时候CPU要**暂停**(stall)。由于内存的频繁访问，这种情况是难以忍受的，解决方法是在CPU与内存之间，增加高速缓存，协调速度差异的内存缓存区。

我们需要确定进程可访问的合法地址的范围，并确保进程只访问其合法地址。用以下两个寄存器来保证。

基址寄存器(base register)
:    含有最小的合法物理内存地址

界限地址寄存器(limit register)
:    决定了范围的大小

内存空间保护的实现，是通过CPU硬件对**用户模式所产生的每一个地址与寄存器的地址进行比较**来完成的。

### 8.1.2 地址绑定

通常，程序以二进制可执行文件的形式存储在磁盘上，为了执行，程序被调入内存并放在进程空间内。根据所使用的内存的内存管理方案，进程**在执行时可以在磁盘和内存之间移动**。在磁盘上等待调入内存以便执行的进程形成**输入队列**(input queue)。

通常的步骤是从输入队列中选取一个进程并装入内存。进程在执行时，会访问内存中的指令和数据。最后，进程终止，其地址空间释放。

许多系统个允许用户进程放在物理内存的任意位置。所以，存在一些地址的转换。在这些过程中，地址可能有不同的表现形式。源程序中的地址通常是用**符号**来表示的。编译器通常将这些符号地址**绑定(bind)**在可重定位的地址。链接程序或加载程序再将这些可重定位地址绑定成绝对地址。**每次绑定都是从一个地址空间到另一个地址空间的映射**。

通常，将指令和数据绑定到内存地址有以下几种情况：
- 编译时（compile time）：确定驻留地址，生成绝对代码。如果将来开始地址发生变化，那么就必须重新编译代码。
- 加载时（load time）：编译时不知道进程的驻留地址，则编译器需要生成可重定位代码（relocatable code）。
- 执行时（execution time）：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行。采用这种方案需要特定的硬件支持。

本章的主要部分就是描述如何在计算机系统中有效地实现这些绑定，并将讨论合适的硬件支持。

### 8.1.3 逻辑地址空间与物理地址空间

CPU所生成的地址通常称为**逻辑地址**（logical address），而内存单元所看到的地址（**即加载到内存地址寄存器（memory-address register）中的地址**）通常称为**物理地址**（physical address）。
编译和加载时的地址绑定方法生成相同的逻辑地址和物理地址。但是，执行时的地址绑定方案导致不同的逻辑地址和物理地址。

逻辑地址空间(logical address space)
:	由程序所生成的所有逻辑地址的集合

物理地址空间(physical address space)
: 	与上面的逻辑地址相对应的所有物理地址的集合

所以，对于执行时地址绑定方案，逻辑地址空间和物理地址空间是不同的。

逻辑地址对应物理地址，和虚拟地址对应实地址，相对地址对应绝对地址，前者和后者分别是同一个概念，只是使用的场合不同。

运行时从虚拟地址到物理地址的映射是由被称为**内存管理单元**（memory-management unit, MMU）的硬件设备来完成的。一种简单映射方案是8.1.1节的基地址寄存器方案的推广：基地址寄存器在这里成为**重定位寄存器**（relocation register）。用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值。

用户进程决不会看到**真正的物理地址**。用户程序处理逻辑地址，内存映射硬件将逻辑地址转变为物理地址。

### 8.1.4 动态加载

一般情况下进程的大小受物理内存大小的限制。为了获得更好的内存空间使用率，可以

使用**动态加载(dynamic loading)**。采用动态加载时，一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。这个优点是不用的子程序决不会被加载。

优点：更好的内存空间使用率，不需要操作系统提供特别的支持。

### 8.1.5 动态链接与共享库

动态链接（dynamic linking）的概念和动态加载相似，只是这里不是将加载延迟到运行时，而是将链接延迟到运行时。

## 8.2 交换

进程可以暂时从内存中交换（swap）到备份存储（backing store）上，当需要再次执行时再调回到内存中，当需要再次执行时再调回到内存中。

如果有一个更高优先级的进程且需要服务，内存管理器可以交换出低优先级的进程，以便可以装入和执行更高优先级的进程。当更高优先级的进程执行完后，低优先级进程可以交换回内存以继续执行。这种交换有时称为**滚出**（roll out）和**滚入**（roll in）。

如果要换出进程，那么必须确保该进程完全处于空闲状态，尤其值得关注的是**待处理的I/O**

## 8.3 连续内存分配

> 内存必须容纳操作系统和各种用户进程，因此应该尽可能有效地分配内存的各个部分。

连续分配内存是一种常用的方法，采用这种方法时，**每个进程位于一个连续的内存区域。**

### 8.3.1 内存映射与保护

通过前面讨论过的重定位寄存器和界限地址寄存器可以实现这种保护。

### 8.3.2 内存分配

多分区方法(multiple-partition method)
:	最为简单的内存分配方法之一就是将内存分为多个固定大小的**分区**（partition）。每个分区只能容纳一个进程。当一个分区空闲时，可以从输入队列中选择一个进程，以调入到空闲分区。当进程终止时，其分区可以可以被其他系统调用。

可变分区方案（variable-partition）
:	操作系统有一个表，用于记录哪些内存可用和哪些内存被占用。一开始，所有内存都可用与用户进程，因此可以作为一大块可用内存，称为孔(hole)。当有新进程需要内存时，为该进程查找足够打的孔。孔内未被分配到的内存可以下次再用。

动态存储分配问题的一种情况（dynamic storage-allocation problem）
:	根据一组空闲孔来分配大小为n的请求。

从一组可用孔中选择一个空闲孔的最为常用方法有：
1. 首次适应(first-fit)：分配第一个足够大的孔。
2. 最佳适应(best-fit)：分配**最小的足够大**的孔。
3. 最差适应(worst-fit)：分配最大的孔。

### 8.3.3 碎片

当所有总的可用内存之和可以满足请求，但并不连续时，这就出现了外部碎片（external fragmentation）。首次和最佳适应算法有外碎片问题。

操作系统通常将内存以固定大小的块为单元（而不是字节）来分配。进程所分配的内存比所需要的要大，这两个数字之差称为内部碎片（internal fragmentation）。

一种解决外部碎片问题的方法是紧缩（compaction）。紧缩的目的是移动内存内容，以便所有空闲空间合并成一块。紧缩仅在重定位是动态并在运行时可采用。

##8.4 分页

### 8.4.1基本方法

帧
:    将**物理内存**分为固定大小的块，称为**帧(frame)**；

页
:     将**逻辑内存**也分为同样大小的块，称为**页(page)**；

他们面向的对象不同。

**分页**内存管理方案允许进程的物理地址空间可以是非连续的。实现分页的基本方法是将物理内存分为固定大小的块，称为**帧**；而将逻辑内存也分成同样大小的块，称为**页**，需要执行进程时，其页从备份存储中调入到可用的内存帧中。备份存储也分为固定大小的块，其大小与内存帧一样。

分页的硬件支持：逻辑上相邻的页，在物理上不一定相邻，通过**页表**做一个mapping。由CPU生成的每个地址分为两个部分：**页号（p）和页偏移（d）**。页号作为**页表**中的索引。页表包含每页所在物理内存的基地址，这些基地址与**页偏移**的组合就形成了物理地址，送交物理单元。因此分页也是一种**动态重定位**。

页号，段号都将作为索引。页偏移指的是在该页里面相对于该页的第一个位置的偏移量！

![分页的地址组合](http://or5jajfqs.bkt.clouddn.com/osnoteChapter8img3.jpg)

![分页的硬件支持](http://or5jajfqs.bkt.clouddn.com/osnoteChapter8img1.jpg)

![逻辑内存和物理内存的分页模型](http://or5jajfqs.bkt.clouddn.com/osnoteChapter8img2.jpg)

1. 页大小（与帧大小一样）是有硬件来决定的，通常为2的幂。
2. 采用分页技术**不会产生外部碎片**：每个帧都可以分配给需要它的进程。不过，分页有可能**有内部碎片**，注意到**分配是以帧为单元进行的**，所以在最后一个帧就有可能用不完。
3. 页大小↑，内部碎片的大小↑；页大小↓，I/O代价↑。（如果进程大小与也大小无关，那么可以合理推测每个进程都可能有半页的内部碎片）。


分页的一个重要特点是用户视角的内存和实际的物理内存的分离。用户程序将内存作为一整块来处理，而且它只包括这一个进程。事实上，一个用户程序和其他程序一起，分布在物理内存上。用户视角的内存和实际的物理内存的差异是同故宫**地址转换硬件协调的**。
操作系统维护着一个叫做帧表（frame table）的数据结构，其中每个条目对应着一个帧，以表示该帧是空闲还是已占用，如果占用，是被哪个（或哪些）进程的哪个页所占用。

### 8.4.2 硬件支持

绝大多数OS为每一个进程分配一个页表。页表的指针与其他寄存器的值（如指令计数器）一起存入PCB中。

页表硬件实现的方法：
1. （最简单）将页表作为一组专用**寄存器**来实现。如果页表比较小那么还是比较合理的
2.  如果页表比较大，就需要将页表放在内存中，并将**页表基寄存器（PTBR）**指向页表的基址。改变页表只需要改变这一寄存器就可以，降低了切换时间。这个时候，访问一个字节需要*两次访问内存*（一次用于页表条目（即通过PTBR查地址），一次用于字节）。这样，内存的访问速度减半。
3.  对于第二点的解决方法：采用小但专用且快粗的硬件缓冲——**转换表缓冲区（TLB）**。TLB是关联的快速内存(cache)。TLB条目由两部分组成：key和value，当关联内存根据给定值查找时，**它会同时与所有的key进行比较，如果找到条目，那么就得到相应的值域。**缺点是受限于价格和大小。
4.  TLB只包括页表中的一小部分条目，和页表一起使用，相当于一个专用的cache，也会由命中率、替换之类的东西。
5.  地址空间标识符（ASID）: 用来唯一地标识进程，并为进程提供地址空间保护。当TLB试图解析虚拟页号的时候，它确保当前运行进程的ASID和虚拟页相关的ASID相匹配。如果不匹配，TLB就失效。（TLB有可能要冲刷或者删除里面旧的地址。）

### 8.4.3 保护

在分页环境下，内存保护是通过与每个帧相关联的**保护位（associating protection bit）**来实现的。通常保护位存在页表中。例子：可以用一个位来定义一个页是可读写还是只读的。也可以很容易地扩展这一方法以提供更细致的保护。用多几位实现这些访问的组合。

还有一个位通常与**页表中**的每一条目相关联：有效-无效位（valid-invalid bit）。当该位为有效时，表示相关的页在进程的逻辑地址空间内，因此是合法（或有效）的页。当该位为无效时，表示相关的页不在进程的逻辑地址空间内。

### 8.4.4 共享页

共享代码对于分时环境特别重要。如果代码是**可重入代码（或纯代码）**, 则可以共享。

可重入代码
:    不能自我修改的代码，它从不会在执行期间改变。

要共享，代码必须能重入。

## <font color="red">8.5 页表结构（不太懂）</font>

本节讨论组织页表的常用技术。页表结构分为层次页表（向前映射页表）、哈希页表、反向页表

### 8.5.1 层次页表
原因：页表过大，不能在内存中连续地分配这个页表。

划分有许多方法。一种方法是使用两级分页算法，就是将页表再分页。

以一个1KB页大小的32位系统为例。一个逻辑地址可被分为22位的页码和10位的页偏移。因为要对页表进行再分页，所以该页号可分为12位的页码和10位的页偏移。
由于地址转换由外向内，这种方案也称为向前映射页表（forward-mapped page table）。

### 8.5.2 哈希页表

处理超过32位地址空间的常用方法是使用哈希页表。并以虚拟页码（也就是最前面的那个）作为哈希值。

哈希页表的每一条目（同一哈希值）都包括一个链表的元素，这些元素哈希成同一位置。每个元素（代表每个页）有3个域：（1）虚拟页码，（2）所映射的帧号，（3）指向链表的下一个元素的指针。

过程：先哈希，然后在链表里面一个一个找，如果找到了就拉出去组合。要注意p往往比r要大，这样子才能够很好地实现虚拟内存的扩充。

### 8.5.3 反向页表

其中虚拟地址为三元组<process-id, page-number, offset>。
优点：减少了存储每个页表所需要的内存空间
缺点：增加了查找页所需要的时间
解决方案：使用哈希页表来将查找限制在一个或少数几个页表条目

## 8.6 分段

用户不愿将内存看作是一个**线性字节数组**，有的包含指令而其他的包含数据。用户通常愿意将内存**看作是一组不同长度的段的集合**，这些段之间并没有一定的顺序。

每个模块或其他数据元素都可以通过**名称**引用。人们会说“主程序”，而并不关心这些元素所在内存的位置。这些段的长度是不同的，其长度是由这些段在程序中的目的所定的。**段内的元素是通过它们距离段首的偏移来指定的**

**分段(segmentation)**就是支持这种用户视角的内存管理方案。逻辑地址空间由**一组段组成**，每个段都有**名称和长度**。地址指定了段名称和段内偏移，因此用户通过两个量来指定地址：段名称和偏移。（在分页中，用户只指定一个地址，该地址通过硬件分为页码和偏移，对于这些，程序员是看不见的。）

分段架构下的逻辑地址为二元组<segment-number, offset>。

与分页类似，分段架构也存在段表（segment table）负责将二维的用户定义地址映射为一维物理地址。段表中的每一个条目包括：
- 段基地址（base）：包含该段在内存中的开始物理地址。
- 段界限（limit）：指定该段的长度。

从逻辑地址空间中拿相应的元素，然后转到表里面去转成物理地址。

同样，也有段表基寄存器（segment-table base register, STBR）指向段表在内存中的位置，以及段表长度寄存器（segment-table length register, STLR）指明被一个程序所使用的段数。
当且仅当段号s小于STLR的值时，段号是合法的。

---

##额外学习的知识
1. number of frames = physical memory size / page size





