# Chapter 3 进程

@(Operating System)

[toc]

## 3.1 进程概念

### 3.1.1 进程

进程是程序的一次执行过程，程序本身并不是进程，程序本身是一个被动的实体，如同存储在磁盘上的文件内容，**而进程是一个活动的实体。**


![process_in_memory](http://or5jajfqs.bkt.clouddn.com/osnote/chapter3/process_in_memory.png)

进程还包括：
1. 程序计数器（当前活动）
2. 堆栈段（临时数据）
3. 数据段（全局变量）
4. 还可能包括堆，是在进程运行期间动态分配的内存。

**进程中所包含的一个或多个执行单元称为线程（thread）**。进程还拥有一个私有的虚拟地址空间，该空间仅能被它所包含的线程访问。

### 3.1.2 进程状态
每个进程可能处于下列状态之一：
- 新的：进程正在被创建
- 运行：指令正在被执行
- 等待：进程等待某个事件的发生（如I/O完成或者收到信号）
- 就绪：进程等待分配处理器
- 终止：进程完成执行

![@process_state|center](http://or5jajfqs.bkt.clouddn.com/osnote/chapter3/process_states.jpg)

### 3.1.3 进程控制块

每个进程在操作系统内用**进程控制块**（process control block, PCB）来表示，其中包含许多与一个特定进程相关的信息。如：
- 进程状态
- 程序计数器
- CPU寄存器
- CPU调度信息
- 内存管理信息
- 记账信息
- I/O状态信息

## 3.2 进程调度

进程调度（process scheduling）
:	选择一个可用的进程到CPU上执行。

### 3.2.1 调度队列

进程进入系统时，会被加到**作业队列**（job queue）中，该队列包括系统中的所有进程。驻留在内存中就绪的、等待运行的进程保存在**就绪队列**（ready queue）中。
等待特定I/O设备的进程列表称为**设备队列**（device queue）。讨论进程调度的常用表示方法是**队列图**。

### 3.2.2 调度程序

进程选择是由相应的**调度程序**（scheduler）来执行的。

![enter image description here](http://or5jajfqs.bkt.clouddn.com/osnote/chapter3/process_scheduling.png)

长期调度程序（long-term scheduler）或作业调度程序（job scheduler）
:	从大容量存储设备的缓冲池中选择进程，并装入内存以准备执行。

中期调度程序（medium-term scheduler）
:	能将进程从内存（或从CPU竞争）中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。(也就是挂起)

短期调度程序（short-term scheduler）或CPU调度程序（CPU scheduler）
:	从准备执行的进程中选择进程，并为之分配CPU。

![enter image description here](http://or5jajfqs.bkt.clouddn.com/osnote/chapter3/adding_midterm_schduling.png)

短期调度程序必须频繁地为CPU选择新进程，而长期调度程序执行得并不频繁。
长期调度程序控制多道程序设计的程度（内存中的进程数量）。

I/O为主的进程（I/O-bound process）多数时间在执行I/O，CPU为主的进程（CPU-bound process）多数时间在计算。

### 3.2.3 上下文切换

上下文切换（context switch）
:	将CPU切换到另一个进程需要**保存当前进程的状态并恢复另一个进程的状态**，这一任务称为上下文切换（context switch）。

当发生上下文切换时，内核会将旧进程的状态保存在器PCB中，然后装入经调度要执行的并已保存的新进程的上下文。
上下文切换时间是额外开销，因为切换时系统并不能做什么有用的工作。

## 3.3 进程操作

### 3.3.1 进程创建

**创建进程称为父（parent）进程，而新进程称为子（child）进程。每个新进程可以再创建其他进程，从而形成了进程树。**

父子进程资源无共享，child被创建时复制了一份parent的PCB，接下来就无关了。优化：**copy on write.**
所以，最后，子进程的资源可能直接来自操作系统，或只来自父进程，父进程可能必须在其子进程之间分配资源或共享资源。

在进程创建时，除了得到各种物理和逻辑资源外，初始化数据（或输入）由父进程传递给子进程。

当进程创建新进程时，有两种执行可能：
1. 父子进程并发执行
2. 父进程等待，直到某个或者全部子进程执行完。

子进程的地址空间可能和父进程完全相同（具有与父进程相同的程序和数据），也可能装入另一个新程序。

1. 通过fork()系统调用，可创建新进程。新进程通过复制原来进程的地址空间而成。这种机制允许父进程和子进程方便地进行通信，两个进程都继续执行位于系统调用`fork()`之后的指令。
2. 在系统调用fork()之后，一个进程会使用系统调用exec()，以用新程序来取代进程的内存空间。采用这种方式，两个进程能互相通信，并能按照各自的方法执行。

### 3.3.2 进程终止

当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时，进程终止。这时，进程可以返回状态值（通常为整数）到父进程。所有进程资源会被操作系统释放。
进程通过适当的系统调用能终止另一个进程。**通常，只有被终止进程的父进程才能执行这一系统调用。**

父进程终止其子进程的原因有很多，如：
1. 子进程使用了超过它所分配到的一些资源（为判定是否发生这种情况，要求父进程有一个检查其子进程状态的机制）
2. 分配给子进程的任务已不再需要
3. 父进程退出，**如果父进程终止，那么操作系统不允许子进程继续**

如果一个进程终止，那么它的所有子进程也将终止。这种现象称为**级联终止（cascading termination）**，通常由操作系统进行。

## 3.4 进程间通信

需要提供环境以允许进程协作的理由有：
1. 信息共享
2. 提高运算速度
3. 模块化
4. 方便

![@进程间通信的两种方法|center](http://or5jajfqs.bkt.clouddn.com/osnote/chapter3/comunicate_between_processes.png)

### 3.4.1 共享内存系统
生产者进程（producer process）产生信息以供消费者进程（consumer process）消费。

无限缓冲（unbounded-buffer）对缓冲大小没有限制。有限缓冲（bounded-buffer）假设缓冲大小固定。

### 3.4.2 消息传递系统

1. 命名
直接通信（direct communication）：
- Send(P, message)：发送消息到线程P
- Receive(Q, message)：接受来自线程Q的消息。

间接通信（indirect communication）：
- Send(A, message)：发送一个消息到邮箱A
- Receive(A, message)：接收来自邮箱A的消息

2. 同步
消息传递可以是阻塞（blocking）或非阻塞（non-blocking）——也称为同步（synchronous）或异步（asynchronous）。
阻塞send
:    发送进程阻塞，知道消息被接收进程或邮箱所接收

非阻塞send
:	发送进程发送消息并再继续操作

阻塞receive
:	接收者阻塞，直到有消息可用

非阻塞receive
:	接收者收到一个有效消息或空消息

3. 缓冲
不管通信是直接的或是间接的，通信进程所交换的消息都驻留在临时队列中。简单地讲，队列实现有三种方法：
- 零容量
- 有限容量
- 无限容量

## 3.5 IPC系统的实现

要留意一下使用POSIX共享内存机制的各种函数调用