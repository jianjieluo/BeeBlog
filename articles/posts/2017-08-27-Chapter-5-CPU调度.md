@(Operating System)[期末复习]

# Chapter 5 CPU调度

CPU调度是多道程序操作系统的基础。通过在进程之间切换CPU，操作系统可以提高计算机的吞吐率。多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。进程执行知道它必须等待，通常等待某些I/O请求的完成。

## 5.1 基本概念

### 5.1.1 CPU-I/O区间周期
进程执行由**CPU执行**和**I/O等待周期**组成。CPU区间与I/O区间交替进行，进程始于CPU区间且终于CPU区间。
### 5.1.2 CPU调度程序

每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由**短期调度程序**或**CPU调度程序**执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。就绪队列不一定就是FIFO队列，队列中的记录通常为PCB。

### 5.1.3 抢占调度

CPU调度决策可在如下4种环境下发生：
1. 当一个进程从运行状态切换到等待状态
2. 当一个进程从运行状态切换到就绪状态
3. 当一个进程从等待状态切换到就绪状态
4. 当一个进程终止时

当调度只能发生在第1和第4两种情况下时，称调度方案是**非抢占的**（nonpreemptive）或**协作的**（cooperative）；否则，称调度方案是**抢占的**（preemptive）。

**就是说，非抢占调度不会调度就绪的进程，而抢占调度会。**

### 5.1.4 分派程序
分派程序（dispatcher）是一个模块，用来**将CPU的控制交给由短期调度程序选择的进程**。其功能包括：
1. 切换上下文
2. 切换到用户模式
3. 跳转到用户程序的合适位置，以重新启动程序

分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。

## 5.2 调度准则
为了比较CPU调度算法，分析员提出了许多准则，准则包括如下：
- **CPU使用率**（CPU utilization）
- **吞吐量**（throughput）：一个时间单元内所完成进程的数量。
- **周转时间**（turnaround time）：从进程提交到进程完成的时间段
- **等待时间**（waiting time）：在就绪队列中等待所花费时间之和
- **响应时间**（response time）：从提交请求到产生第一响应的时间。是开始响应所需要的时间，而不是输出响应所需要的时间。

需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。

## <font color="red">5.3 调度算法</font>

学会画各种调度算法的甘特图

### 5.3.1 先到先服务调度(FCFS)

优点：简单
缺点：平均等待时间通常较长

所有其他进程都等待一个大进程释放CPU，这称为护航效果（convoy effect）。

FCFS调度算法时非抢占的。一旦CPU被分配给了一个进程，该进程就会保持CPU直到释放CPU为止，即进程终止或是请求I/O。

### 5.3.2 最短作业优先调度（SJF）

SJF = shorthest-job-first = 最短作业优先
最短的先上，一样长的就FCFS。

SJF里又分为抢占与非抢占两种，区别在于是否会抢占已经进入CPU的进程。
抢占SJF调度有时称为**最短剩余时间优先调度**（shortest-remaining-time-first scheduling）。

优点：SJF调度算法是最优的。
缺点：无法在短期CPU调度层次上加以实现，因为没有办法知道下一个CPU区间的长度

解决方案：利用指数平均预测下一个CPU区间的长度
下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均（exponential averaging）。因此，对于，定义公式定义了一个指数平均。tn值包括最近信息，值存储了过去历史，参数控制了最近和过去历史在预测中的相对加权。
Hint: 指数平均肯定是不会要你去算的，但可能会问你指数平均是什么

### 5.3.3 优先级调度

SJF属该种调度的特例。每个进程都有一个优先级，具有最高优先级的进程会分配到CPU，一样高就FCFS。
在本书中，用小数字表示高优先级。

同样分为抢占与非抢占两种。当一个进程到达就绪队列时，其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前进运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。

缺点：低优先级进程可能会饥饿。
解决办法：老化，逐渐增加在系统中等待很长时间的进程的优先级。

### 5.3.4 轮转法调度（round-robin, RR）

RR调度算法是专门为分时系统设计的。它类似于FCFS调度，但是**增加了抢占以切换进程**。定义一个较小时间单元，称为**时间片（time slice）**。将就绪队列作为循环队列，CPU调度程序循环就绪队列，为每个进程分配不超过一个时间片的CPU。

为了实现RR调度，将就绪队列保存为进程的FIFO队列。新进程增加到就绪队列的尾部。CPU调度程序从就绪队列中选择第一个进程，如果进程的执行时间小于时间片，那么进程执行完后自动释放CPU，调度程序接着处理就绪队列中的下一个进程。如果当前运行进程的CPU区间比时间片要长，定时器会中断并产生操作系统中断，然后进行上下文切换，然后将进程加入到就绪队列的尾部，接着CPU调度程序会选择就绪队列中下一个进程。

特点：RR算法的性能很大程度上依赖于时间片的大小。如果时间片非常大，那么RR算法和FCFS算法一样，如果时间片很小，那么RR算法称为处理器共享。

然而，由于上下文切换需要一定的时间，因此时间片不能太小，否则额外消耗过高，人们希望时间片要比上下文切换时间长。

### 5.3.5 多级队列调度
多级队列调度算法（multilevel queue scheduling algorithm）将就绪队列分成多个独立队列。每个队列有自己的调度算法。进程无法在就绪队列之间移动。

队列之间必须有调度，通常采用固定优先级抢占调度。另一种可能是在队列之间划分时间片。

队列内部：可为任意调度算法
队列之间：优先级抢占，或轮转

优点：低调度开销
缺点：不够灵活

### 5.3.6 多级反馈队列调度
多级反馈队列调度算法（multilevel feedback queue scheduling algorithm）在多级队列调度算法的基础上**允许进程在队列之间移动。**

如果进程使用过多CPU时间，那么它会被转移到更低优先级队列。在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。
优点：这种老化机制防止了饥饿。

具体操作：每个队列都有自己固定的时间片，如果一个进程不能在这个时间片之内完成，那么就会被下放到下一个队列里。

## 5.4 多处理器调度

非对称多处理：让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码。

对称多处理（symmetric multiprocessing, SMP）：每个处理器自我调度。调度通过每个处理器检查共同就绪队列并选择一个进程来执行，要注意实现确保两个处理器不能选择同一个进程，且进程不会从队列中丢失。

